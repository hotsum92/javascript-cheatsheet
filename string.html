<html>
  <head>
    <title>string</title>
  </head>
  <body>
    <h1>string</h1>
    <script>

// 2 行文字列を 1 行で記述
'two\nlines'
// 1 行文字列を 3 行で記述
"one\
long\
line"

// 2 行文字列を 2 行で記述
`the newline character at the end of this line
is included literally in this string`

let s = "Hello, world"; // 例となるテキスト

// 文字列の一部を取得
s.substring(1,4) // "ell": 2 番目と 3 番目と 4 番目の文字
s.slice(1,4)     // "ell": 同じ処理
s.slice(-3)      // "rld": 最後から 3 文字
s.split(", ")    // ["Hello", "world"]: 区切り文字で、文字列を分割

// 文字列の検索
s.indexOf("l")     // 2: 最初の l の位置
s.indexOf("l", 3)  // 3: 3 文字目以降で最初の l の位置
s.indexOf("zz")    // -1: s には「 zz 」という文字列は含まれていない
s.lastIndexOf("l") // 10: 最後の l の位置

// 論理値を返す検索関数（ ES6以降）
s.startsWith("Hell") // => true: この文字列から始まっている
s.endsWith("!")      // => false: s の末尾はこの文字列ではない
s.includes("or")     // => true: s には「 or 」という文字列が含まれている

// 一部を変更した文字列を作成
s.replace("llo", "ya") // => "Heya, world"
s.toLowerCase() // => "hello, world"
s.toUpperCase() // => "HELLO, WORLD"
s.normalize() //
s.normalize("NFD")
// Unicode の NFC 正規化を行う（ ES6 ）
// NFD 正規化を行う「 NFKC 」、「 NFKD 」も使える。

// 文字列中の個々の文字（ 16 ビット）の処理。
s.charAt(0) // => "H": 最初の文字。
s.charAt(s.length-1) // => "d": 最後の文字。
s.charCodeAt(0) // => 72: 指定した位置の文字の 16 ビット値。
s.codePointAt(0) // => 72: 16 ビットよりも大きな符号位置にも使える（ ES6 ）。

// ES2017 で追加された文字列パディング関数。
"x".padStart(3)       // => " x":      左側に空白を追加して、 3 文字にする。
"x".padEnd(3)         // => "x ":        右側に空白を追加して、 3 文字にする。
"x".padStart(3, "*")  // => "**x":左側に「 * 」を追加して、 3 文字にする。
"x".padEnd(3, "-")    // => "x--":  右側に「 - 」を追加して、 3 文字にする。

// 空白を削除する関数。 trim() のみ ES5 から。ほかは ES2019 から。
" test ".trim() // => "test": 先頭と末尾の空白を削除。
" test ".trimStart() // => "test ": 左側の空白を削除。 trimLeft と記述してもよい。
" test ".trimEnd() // => " test": 右側の空白を削除。 trimRight と記述してもよい。

// そのほかの文字列メソッド。 s.concat("!")
// => "Hello, world!": 代わりに + 演算子を使うだけでもよい。
"<>".repeat(5) // => "<><><><><>": 文字列を繰り返して結合する（ ES6 ）。

let name = "Bill";
let greeting = `Hello ${ name }.`; // greeting == "Hello Bill."

let errorMessage = `\
\u2718 Test failure at ${filename}:${linenumber}:
${exception.message}
Stack trace:
${exception.stack}
`;

String.raw`\n`.length // => 2: バックスラッシュ文字と、 n という文字

let text = "testing: 1, 2, 3"; // 例となるテキスト。
let pattern = /\d+/g;          // 1 個以上の数字列にすべてマッチ。
pattern.test(text)             // => true: マッチする部分が存在する。
text.search(pattern)           // => 9: 最初にマッチした文字の位置。
text.match(pattern)            // => ["1", "2", "3"]: すべてのマッチを含む配列。
text.replace(pattern, "#")     // => "testing: #, #, #"
text.split(/\D+/)              // => ["","1","2","3"]: 数字以外の文字で配列に分割。

Number("3") // => 3
String(false) // => "false": false.toString() でも変換可。
Boolean([]) // => true

let n = 17;
let binary = "0b" + n.toString(2); // binary == "0b10001"
let octal = "0o" + n.toString(8);  // octal == "0o21"
let hex = "0x" + n.toString(16);   // hex == "0x11"

let n = 123456.789;
n.toFixed(0) // => "123457"
n.toFixed(2) // => "123456.79"
n.toFixed(5) // => "123456.78900"
n.toExponential(1)// "1.2e+5"
n.toExponential(3)// "1.235e+5"
n.toPrecision(4)  // "1.235e+5"
n.toPrecision(7)  // "123456.8"
n.toPrecision(10) // "123456.7890"

parseInt("3 blind mice")
parseFloat(" 3.14 meters")
parseInt("-12.34")
parseInt("0xFF")
parseInt("0xff")
parseInt("-0XFF")
parseFloat(".1")
parseInt("0.1")
parseInt(".1")
parseFloat("$72.47")

parseInt("3 blind mice")  // 3
parseFloat(" 3.14 meters")// 3.14
parseInt("-12.34")        // -12
parseInt("0xFF")          // 255
parseInt("0xff")          // 255
parseInt("-0XFF")         // -255
parseFloat(".1")          // 0.1
parseInt("0.1")           // 0
parseInt(".1")            // NaN: 整数の場合、「 . 」が先頭にくることはない。
parseFloat("$72.47")      // NaN: 数値は「 $ 」が先頭にくることはない。

parseInt("11", 2)  // 3: (1*2 + 1)
parseInt("ff", 16) // 255: (15*16 + 15)
parseInt("zz", 36) // 1295: (35*36 + 35)
parseInt("077", 8) // 63: (7*8 + 7)
parseInt("077", 10)// 77: (7*10 + 7)

    </script>
  </body>
</html>
